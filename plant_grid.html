<!DOCTYPE html>  
<html lang="en"> 

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />  
<meta name="viewport" content="width=device-width, minimum-scale=1.0" />
<meta name="description" content="Garden Viewer Grid" />
<meta charset="utf-8">
<link rel="icon" type="image/png" href="plant-icon-96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="plant-icon-96.svg" />
<link rel="shortcut icon" href="plant-club.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="plant-icon-192.png" />
<meta name="apple-mobile-web-app-title" content="Garden Viewer Grid" />
<link rel="manifest" href="plant_club.webmanifest" />
<link rel="stylesheet" type="text/css" href="seed_library.css" />
<script type="text/javascript" src='common_func.js'> </script>
<script type="text/javascript" src='observations_grid.js'> </script>
<title>Garden Viewer Grid</title>
</head>

<body>
<script src="https://cdn.jsdelivr.net/gh/stockslager/inat/js/plant_params_v10.js"></script>

<script>
//get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr);
let p_project_id = winurlparams.get('project_id') || '';
let p_taxon_id   = winurlparams.get('taxon_id') || '';
let p_taxon_nm   = winurlparams.get('taxon_nm') || 'Show';
var cellpx       = winurlparams.get('cellpx') || 122;
var spacerpx     = winurlparams.get('spacerpx') || 4;
var rows         = winurlparams.get('rows') || 30;
var columns      = winurlparams.get('columns') || 3;
let p_action     = winurlparams.get('action') || '';
let p_list       = winurlparams.get('list') || '';
let p_tag_name   = winurlparams.get('tag_name') || '';
let p_menu       = winurlparams.get('menu') || '';
let p_plant_id   = winurlparams.get('plant_id') || '';
let p_plant_name = winurlparams.get('plant_name') || '';
let p_cache_check = winurlparams.get('cache_check') || '';
let p_life       = winurlparams.get('life') || 'Life Stage';
let p_state      = winurlparams.get('state') || '';
let p_hide_home  = winurlparams.get('hide_home') || 'no';
let p_hide_dds   = winurlparams.get('hide_dds') || 'no';

// parse the seed project param to determine mode.
let prj      = p_state.split('$')[0];
let place    = p_state.split('$')[1];
let p_params = p_state.split('$')[2];
let user     = p_state.split('$')[3];
let garden   = p_state.split('$')[4];
let mode     = p_state.split('$')[5];

// don't show organsims that have only been id'd to genus and above, otherwise the number's
// won't match other counts
//winurlparams.append('lrank', 'subspecies');

let annotations_array = [];
let interactions = [];
let configuration = '';

let seed_param = '';
if( p_state ) {
    state_param = '&state='+p_state;
}

let all_opts = copyOpts(winurlparams);

let all_except_life_stage = '';
for (const [key, value] of winurlparams.entries()) { 
  if( key !== 'life' && key !== 'term_id' && key !== 'term_value_id' ) {
      if( all_except_life_stage === '' ){
          all_except_life_stage += "?";
      } else {
          all_except_life_stage += "&";
      }
      all_except_life_stage += key;
      all_except_life_stage += "=";

      if( key === 'page' ){
          all_except_life_stage += '1';
      } else {
          all_except_life_stage += value;
      }
  }
}   
   
// if the user has selected a method, built the opt to pass to the
// lifelist page.
// find key/value pair for &field: param if one was passed in
let field = '';
let p_field_value = '';
let opts = '';
let field_key = '';
for (const [key, value] of winurlparams.entries()) {
  if( key.startsWith('field') ){
      field_key = key;
      opts += ('&'+key+'='+value);
      field = ('&'+key+'='+value);
      p_field_value = value;
  }
}   

if( p_taxon_id ) {
    opts      += ('&taxon_id='+p_taxon_id);
}

var recsmax = columns * rows - 1;

winurlparams.delete('cellpx');
winurlparams.delete('spacerpx');
winurlparams.delete('rows');
winurlparams.delete('columns');
var obsurlbase = 'https://www.inaturalist.org/observations';
var obsurl = obsurlbase+'?'+winurlparams.toString();
winurlparams.append('per_page',recsmax);
var apiurlbase = 'https://api.inaturalist.org/v1/observations'
var apiurl = apiurlbase+'?'+winurlparams.toString();

function getShowDDOpts( winurlparams ) { 
   let opts='';
   // build param list for url's used in fresults
   for( const [key, value] of winurlparams.entries() ) { 
        if( key !== 'taxon_id' && key !== 'taxon_nm' && key !== 'page' && key !== 'per_page' && key !== 'lrank' ){
            if( opts === '' ){
                opts += "?";
            } else {
                opts += "&";
            }
            opts += key;
            opts += "=";
            opts += value;
        }
   } 
   return( opts );
}

function buildArtistMenu(data, obs_fields) {
   let links = '';
   let menu_string = '';

   menu_string = '<div class="navbar">';

   if( p_hide_dds === 'no' ) {
       // show drop down to filter by taxa
       if( configuration.sub_icons ) { 
           let showDDOpts = getShowDDOpts( winurlparams );

           // plantae is hard-coded because we only want to appear on the artists grid and not
           // in the "show" drop down used on the counts page.  may need to re-visit.
           links =  (furl(github_root+'plant_grid.html'+showDDOpts,'<span style="padding-right:20px;">&#10133;</span>all' ));
           links += (furl(github_root+'plant_grid.html'+showDDOpts+'&taxon_id=47126','<span style="padding-right:20px;">&#127807;</span>plants' )); 
           for( let j=0; j<configuration.sub_icons.length; j++ ) {
                links += (furl(github_root+'plant_grid.html'+showDDOpts+'&taxon_id='+configuration.sub_icons[j].taxon_id+'&taxon_nm='+configuration.sub_icons[j].nm,'<span style="padding-right:20px;">'+configuration.sub_icons[j].icon+'</span>'+configuration.sub_icons[j].nm ));
           }
              
           menu_string += ( buildDD( capitalizeWords(p_taxon_nm), links) );
       }
   }

   if( p_hide_home === 'no' ) {
       if( mode && mode.includes('seed') ) {
           menu_string += buildHome( furl(github_root+'plant_seeds_detail.html?state='+p_state,'&#127807;') );
       } else {
           menu_string += buildHome( furl(github_root+'plant_artists.html?state='+p_state,'&#127807;') );
       }
   }

   menu_string += '</div>';
   
   return menu_string;

}
  
function buildLifeStageMenu(data, obs_fields) {

   let links = '';
   let menu_string = '';

   if( mode && mode.includes('artist') ) {
       return (buildArtistMenu(data, obs_fields));
   }

   menu_string = '<div class="navbar">';

   if( p_hide_dds === 'no' ) {
       if( mode && !mode.includes('visitors') && !mode.includes('observers') && !mode.includes('seeds') ) {
           links = furl(github_root+'plant_grid.html'+all_opts,"grid");
           if( field_key ) {
               links += furl(github_root+'plant_activity_list.html'+all_opts+'&obs_fields='+obs_fields,"list");
           }
           links += furl(github_root+'plant_map.html'+all_opts,"map");
           menu_string += buildDD('Show', links);
       }
   }

   // the life list links need to be cached the first time the page is enetered 
   // otherwise when a life stage is chosen the grid will only display that
   // life stage and the drop down will only see that life stage and (all) 
   // since the other life stages are filtered out.
   let cache_key = ('project_id='+p_project_id+'taxon_id='+p_taxon_id+'field='+field);

   links = '';
   if( p_cache_check === 'yes' ) {
       if( sessionStorage.getItem(cache_key) ) {
           console.log('found cache..: '+cache_key+'==='+sessionStorage.getItem(cache_key));
           links += sessionStorage.getItem(cache_key);
       }
   }

   if( !links ) {
       // all should always appear...
       links = furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=&cache_check=yes','All');
   
       if( annotations_array.includes(2) ){      // adult
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Adults&term_id=1&term_value_id=2&cache_check=yes','Adults');
       }
       if( annotations_array.includes(3) ){      // teneral
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Teneral&term_id=1&term_value_id=3&cache_check=yes','Teneral');
       }
       if( annotations_array.includes(4) ) {    // pupa
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Pupa&term_id=1&term_value_id=4&cache_check=yes','Pupa');
       }
       if( annotations_array.includes(5) ) {    // nymph
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Nymph&term_id=1&term_value_id=5&cache_check=yes','Nymph');
       }
       if( annotations_array.includes(6) ){      // larva.
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Larva&term_id=1&term_value_id=6&cache_check=yes','Larva');
       }
       if( annotations_array.includes(7) ) {    // egg
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Egg&term_id=1&term_value_id=7&cache_check=yes','Egg');
       }
       if( annotations_array.includes(8) ) {    // juvenile
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Juvenile&term_id=1&term_value_id=8&cache_check=yes','Juvenile');
       }
       if( annotations_array.includes(16) ) {    // subimago
           links += furl(github_root+'plant_grid.html'+all_except_life_stage+'&life=Subimago&term_id=1&term_value_id=16&cache_check=yes','Subimago');
       }
       sessionStorage.setItem(cache_key, links);
   }

   if( p_hide_dds === 'no' ) {
       menu_string += buildDD(p_life, links);
   }

   if( p_hide_home === 'no' ) {
       menu_string += buildHome( furl(github_root+'plant_activity.html?state='+p_state+'&target_id='+p_plant_id+'&target_name='+p_plant_name,'&#127807;') );
   }

   menu_string += '</div>';
   
   return menu_string;
}

function buildMenu(data) {

  let obs_fields = '';
  for( let j=0; j<data.results.length; j++ ) {
       checkForAnnotations(data.results[j]);
      
       // find the obs field that matches the one that passed in and save the id
       // to pass to the "list" if that option is chosen in the "show" drop-down.
       if( j === 0 ){
           if( interactions ) {
               for( let i=0; i<interactions.length; i++ ) {
                    if( interactions[i].dd_menu === p_project_id && 
                        interactions[i].field_name.toLowerCase() === field_key.replace("field:",'').toLowerCase() ) {
                        obs_fields = interactions[i].obs_field_list;
                    }
                }
            }
            // if there weren't interactions added to the .json,
            // just pass along whichever obs_fields were passed to the grid.
            if( !obs_fields ) {
                for( let i=0; i<data.results[j].ofvs.length; i++ ) {
                     if( data.results[j].ofvs[i].name.toLowerCase() === field_key.replace("field:",'').toLowerCase() ) {
                         obs_fields = data.results[j].ofvs[i].field_id;
                     }
                 }
            }
       }
  }

  return( buildLifeStageMenu(data, obs_fields) );
}

function checkForAnnotations( obs ){
   if( obs.annotations ) {
       for( let i=0; i<obs.annotations.length; i++ ) {
            // eventually this hard coding would need to be removed.
            // it should call the get_observations_popular_field_values on page load
            // and store the results in session for use when the menu is clicked.
            // replace session on re-load of page.
            if( obs.annotations[i].controlled_attribute_id === 1 ) {   // life stage
                if( !annotations_array.includes(obs.annotations[i].controlled_value_id) ) {
                    annotations_array.push(obs.annotations[i].controlled_value_id);
                }
            }
       }
   }
}
  
function fresults(data) {  
   faddelem('p',document.body,{innerHTML:buildMenu(data)}); 
   buildGrid(data);    
};

async function asyncGetData() {
   console.log('json ' + json_root+p_params);
   await fetch((json_root+p_params+'.json'))
     .then(response => response.json())
     .then(data => {
      // Access your data here 
      for( let i=0; i<data.configurations.length; i++ ) {
           if( data.configurations[i].insect_project === p_project_id ) {
               interactions = data.configurations[i].interactions;
           }
           if( data.configurations[i].art_project === p_project_id ) {
               configuration = data.configurations[i];
           }
      }
      console.log(data);
   })
     .catch(error => {
      console.error('Error fetching JSON:', error);
   });

   if (window.location.search==='') {
      faddelem('p',document.body,{innerHTML:'This is a quick and dirty example of a widget to display iNaturalist observations in a grid. It is based on the '+furl('https://api.inaturalist.org/v1/docs/#!/Observations/get_observations','Observation Search API endpoint')+' and can accept any of the parameters for that endpoint. Additionally, it accepts 4 more parameters that will allow the grid to be customized: columns, rows, cellpx, and spacerpx.'});
      faddelem('p',document.body,{innerHTML:'Suppose the address of this page is '+furl(winurlexsearchstr)+', and you want to see '+furl(famp(apiurlbase+'?taxon_id=3&place_id=9'),'birds in New Mexico')+' in a 3 (high) x 5 (wide) grid where each cell is 75px x 75px and where each cell is separated by a 2px spacer, then you would open '+furl(famp(winurlexsearchstr+'?rows=3&columns=5&cellpx=75&spacerpx=2&taxon_id=3&place_id=9'))+' in your browser.'});
      faddelem('p',document.body,{innerHTML:'Note that the actual size of the image files is 75px x 75px. So setting the cellpx higher than 75 will make the images look blurry. Only the first photo in an observation will be shown, or else âŽ will be shown when an observation has no photos. The last cell in the grid will always be either a "no data" or "more" button. So a 3x5 grid will show only up to 14 observations.'});
   } else {
        await fetch(apiurl)
          .then((response) => {
             if (!response.ok) { throw new Error(response.status+' ('+response.statusText+') returned from '+response.url); };
             return response.json();
          })
          .then((data) => { fresults(data); })
          .catch((err) => {
             console.error(err.message);
             faddelem('p',document.body,{innerHTML:'There was a problem retrieving data. Error '+err.message+'.'})
        });
   };

}

// need to pull resources from a json file to pass into an api
// so needs to be asynchronous. 
const request = async () => {
   asyncGetData();
}

request();  
 
</script>
</body>

</html>
