<!DOCTYPE html> 
<html lang="en"> 
 
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0" />
<meta name="description" content="Explorers" />
<link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="Explorers" />
<link rel="manifest" href="fish.webmanifest" />
<link rel="stylesheet" type="text/css" href="seed_library.css" />
<script type="text/javascript" src='common_func.js'> </script>
<title>Explorers</title>
</head>

<body>
<script>
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
let p_sort       = winurlparams.get('sort') || 'dspecies';
let p_place_name = winurlparams.get('place_name') || '';
let p_tname      = winurlparams.get('tname') || '';
let p_place_id   = winurlparams.get('place_id') || '';
let p_project_id = winurlparams.get('project_id') || '';
let p_taxon_id   = winurlparams.get('taxon_id') || '';

// cache check of session storage to make app less expensive to server (cache check, get it!  bwahahaha)
// session storage is only used for sorting of data in columns at this point.
let p_cache_check = winurlparams.get('cache_check') || 'no';  
 
// if the user has selected a method, built the opt to pass to the
// lifelist page.
let p_field_opt = '';
let p_field_value = '';
// find key/value pair for &field: param if one was passed in
for (const [key, value] of winurlparams.entries()) {
  if( key.startsWith('field') ){
      p_field_value = value;
      p_field_opt = ('&'+key+'='+value);
  }
}   

let place_opt = '';
let taxon_opt = '';
let sort_opt  = '';
let opts = ''

if( p_place_id ) {
    place_opt += ('&place_id='+p_place_id);
    opts      += ('&place_id='+p_place_id);
    if( p_place_name ) {
        opts      += ('&place_name='+p_place_name);
        place_opt += ('&place_name='+p_place_name);
    }
}

if( p_taxon_id ) {
    taxon_opt += ('&taxon_id='+p_taxon_id);
    opts      += ('&taxon_id='+p_taxon_id);
    if( p_tname ) {
        taxon_opt += ('&tname='+p_tname);
        opts      += ('&tname'+p_tname);
    }
}

if( p_sort ) {
    sort_opt += ('&sort='+p_sort);
}
   
let view = winurlparams.get('view') || '';
let activity_data = winurlparams.get('activity_data') || 'local';
winurlparams.delete('activity_data');
</script>
   
<script src="https://cdn.jsdelivr.net/gh/stockslager/inat/rewild_common_func_v2.js"></script>
<script src="https://cdn.jsdelivr.net/gh/stockslager/inat/library_params_v7.js"></script>

<script>

function furlArrow(url,txt=url) { return '<a href="'+url+'" id="arrow">'+txt+'</a>'; };

function findValueByKey(arr, key, value) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i][key].toString() === value) {
      return arr[i];
    }
  }
  return undefined;
}

function sortWithNull(arr, ascending) {
  for( let i=0; i<arr.length; i++ ) {
       if( arr[i].user_login ){
           arr[i].user_login = arr[i].user_login.toLowerCase();
       }
  }
  arr.sort(function(a, b) {
    if (!a.user_login && !b.user_login) return 0;
    if (!a.user_login) return ascending ? 1 : -1;
    if (!b.user_login) return ascending ? -1 : 1;
    if (a.user_login < b.user_login) return ascending ? -1 : 1;
    if (a.user_login > b.user_login) return ascending ? 1 : -1;
    return 0;
  });
  return arr;
}

function sortWithNullSpecies(arr, ascending) {
  arr.sort(function(a, b) {
    if (!a.species_count && !b.species_count) return 0;
    if (!a.species_count) return ascending ? 1 : -1;
    if (!b.species_count) return ascending ? -1 : 1;
    if (a.species_count < b.species_count) return ascending ? -1 : 1;
    if (a.species_count > b.species_count) return ascending ? 1 : -1;
    return 0;
  });
  return arr;
}

function sortWithNullObs(arr, ascending) {
  arr.sort(function(a, b) {
    if (!a.obs_count && !b.obs_count) return 0;
    if (!a.obs_count) return ascending ? 1 : -1;
    if (!b.obs_count) return ascending ? -1 : 1;
    if (a.obs_count < b.obs_count) return ascending ? -1 : 1;
    if (a.obs_count > b.obs_count) return ascending ? 1 : -1;
    return 0;
  });
  return arr;
}
 
function fresults(result, places_obj, taxa_obj) {

      // places menu...
      let places_menu = furl(github_root+'life_list_dashboard.html?project_id=239695'+sort_opt+taxon_opt+p_field_opt,'All');
      for( let i=0; i<places_obj.places.length; i++ ) {
           places_menu += furl(github_root+'life_list_dashboard.html?project_id=239695'+sort_opt+taxon_opt+p_field_opt+'&place_id='+places_obj.places[i].place_id,places_obj.places[i].place_name);
      }
      places_menu += furl(github_root+'life_list_places.html','Select Custom Place');

      // taxa menu...
      let taxa_menu = furl(github_root+'life_list_dashboard.html?project_id=239695'+sort_opt+place_opt+p_field_opt,'All');
      for( let i=0; i<taxa_obj.taxa.length; i++ ) {
           taxa_menu += furl(github_root+'life_list_dashboard.html?project_id=239695'+sort_opt+place_opt+p_field_opt+'&taxon_id='+taxa_obj.taxa[i].taxon_id+'&tname='+taxa_obj.taxa[i].taxon_name,taxa_obj.taxa[i].taxon_name);
      }
  
      let place_name  = 'Place';
      let taxon_name  = 'Taxa';
      let method_name = 'Method';
      if( p_place_id ) {
          if( p_place_name ) {
              place_name = p_place_name;
          } else {
             const place = findValueByKey(places_obj.places, 'place_id', p_place_id); 
             place_name = place.place_name;
          }
      } 
      if( p_taxon_id ) {
          const taxon = findValueByKey(taxa_obj.taxa, 'taxon_id', p_taxon_id); 
          taxon_name = taxon.taxon_name;
      }  
      if( p_field_value ) {
          method_name = p_field_value;
      }
 
      faddelem('p',document.body,{innerHTML:('<div class="navbar">' +
                                                   /*'<a href="#news">News</a>' +*/
                                                      '<div class="dropdown">' +
                                                           '<button class="dropbtn">' + place_name +
                                                             '<i class="fa fa-caret-down"></i>' +
                                                           '</button>' +
                                                           '<div class="dropdown-content">' +
                                                                 places_menu +
                                                           '</div>' +
                                                       '</div>' +
                                                      '<div class="dropdown">' +
                                                           '<button class="dropbtn">' + taxon_name +
                                                             '<i class="fa fa-caret-down"></i>' +
                                                           '</button>' +
                                                           '<div class="dropdown-content">' +
                                                                 taxa_menu +
                                                           '</div>' +
                                                       '</div>' + 
                                                      '<div class="dropdown">' +
                                                           '<button class="dropbtn">' + method_name +
                                                             '<i class="fa fa-caret-down"></i>' +
                                                           '</button>' +
                                                           '<div class="dropdown-content">' +
                                                                 furl(github_root+'life_list_dashboard.html?project_id=239695'+taxon_opt+place_opt+sort_opt,'All') +
                                                                 furl(github_root+'life_list_dashboard.html?field:fish+observation+method=Angling+(Conventional)'+opts+sort_opt,'Angling (Conventional)') +
                                                                 furl(github_root+'life_list_dashboard.html?field:fish+observation+method=Microfishing'+opts+sort_opt,'Microfishing') +
                                                                 furl(github_root+'life_list_dashboard.html?field:fish+observation+method=Fly+Fishing'+opts+sort_opt,'Fly Fishing') +
                                                                 furl(github_root+'life_list_dashboard.html?field:fish+observation+method=Ice+Angling'+opts+sort_opt,'Ice Angling') +
                                                           '</div>' +
                                                       '</div>' + 
                                              '</div>')});
 
   if (result) {

      // may need to revisit this if there is more than one page of data
      let user_toggle    = 'uuser';
      let species_toggle = 'dspecies';
      let obs_toggle     = 'dobs';
      if( p_sort === 'uuser' )    { result.recs = sortWithNull(result.recs, true);         user_toggle='duser'; }
      if( p_sort === 'duser' )    { result.recs = sortWithNull(result.recs, false);        user_toggle='uuser'; }
      if( p_sort === 'uspecies' ) { result.recs = sortWithNullSpecies(result.recs, true);  species_toggle='dspecies'; }
      if( p_sort === 'dspecies' ) { result.recs = sortWithNullSpecies(result.recs, false); species_toggle='uspecies'; }
      if( p_sort === 'uobs' )     { result.recs = sortWithNullObs(result.recs, true);      obs_toggle='dobs'; }
      if( p_sort === 'dobs' )     { result.recs = sortWithNullObs(result.recs, false);     obs_toggle='uobs'; }

      let total_results = result.total_results;
      let per_page = result.per_page;
      let page_curr = result.page;
      let page_max = Math.ceil(total_results/per_page);
      let page_prev = ((page_curr>1)?page_curr-1:null);
      let page_next = ((page_curr<page_max)?page_curr+1:null);

    
      //faddelem('p',document.body,{innerHTML:('<span id="topright">'+nav_position+'</span></div></span>')});

      faddelem('p',document.body,{innerHTML:'project members: '+fcomnum(total_results)+'<br />' 
            +'per page: '+fcomnum(per_page)+'<br />'
            +'page: '+fcomnum(page_curr)+' of '+fcomnum(page_max)+'<br />'
            });

      let table = faddelem('table',document.body,{id:'main'});
      let thead = faddelem('thead',table);
      let hrow = faddelem('tr',thead);

      let sort_url = (github_root+'life_list_dashboard.html?project_id=239695'+opts+'&cache_check=yes');
      let arrows = ('<img class="arrows" src="'+github_root+'arrows.png"/>');
                      
      let labels = [
         {innerText:'#'},
         {innerText:'Icon '},
         {innerHTML:furlArrow(sort_url+'&sort='+user_toggle,'Name'+arrows)},
         {innerHTML:furlArrow(sort_url+'&sort='+species_toggle,'Spc'+arrows)},
         {innerHTML:furlArrow(sort_url+'&sort='+obs_toggle,'Obs'+arrows)},
      ];
      faddelems('th',hrow,labels);
      
      let tbody = faddelem('tbody',table);
      for (let i=0; i<result.recs.length; i++) {
         let target_url = '';     
         let brow = faddelem('tr',tbody);
         let rec = result.recs[i];
         let lists = '';
         let user_icon = rec.icon || '';
         
         if( user_icon === '' ){
            user_icon += '<div class="npcicon">&#x1F464;</div>';
         } else {
            user_icon = '<img class="exp_icon" src="'+user_icon+'" />';
         }

         let params = ('life_list.html?project_id=239695&user_id='+rec.user_login/*+'&tag_name=lifelist'*/+p_field_opt);
         let detail_params = ('configurable_obs_field_table.html?project_id=239695&user_id='+rec.user_login+'&obs_fields=17274,7615');

         if( rec.user_login === 'uconnbirdfish' ){
             params = ('life_list.html?project_id=239695&user_id='+rec.user_login+'&tag_name=pegslifelist');
             params = ('life_list.html?project_id=239695&user_id='+rec.user_login+opts);
         }

         let map = furl(github_root+'life_list_map.html?project_id=239695'+opts+'&user_id='+rec.user_login,'<span class="globe">&#127758</span>');
       
         let values = [
            {innerText:i+1},
            {innerHTML:user_icon},
            {innerHTML:furl(root_people+rec.user_login,rec.user_login)+map},
            {innerHTML:furl(github_root+params+opts,rec.species_count )},
            {innerHTML:furl(github_root+'life_list_grid.html?project_id=239695&user_id='+rec.user_login+'&angler='+rec.user_login+opts+p_field_opt,rec.obs_count)},
         ];
         faddelems('td',brow,values);
      };

      // buttons to go to prev or next page
      let nav = faddelem('div',document.body,{id:'nav'});
      (page_curr<=1)?faddelem('span',nav,{classList:'button_inactive',title:'already on first page',innerHTML:'&laquo'}):faddelem('a',nav,{classList:'button',title:'first page',id:'button_first',innerHTML:'&laquo',href:fpageurl(winurlexsearchstr,winurlparams,per_page,1)});
      (page_prev===null)?faddelem('span',nav,{classList:'button_inactive',title:'no previous page',innerHTML:'&#8249'}):faddelem('a',nav,{classList:'button',title:'previous page',id:'button_prev',innerHTML:'&#8249',href:fpageurl(winurlexsearchstr,winurlparams,per_page,page_prev)});
      (page_next===null)?faddelem('span',nav,{classList:'button_inactive',title:'no next page',innerHTML:'&#8250'}):faddelem('a',nav,{classList:'button',title:'next page',id:'button_next',innerHTML:'&#8250',href:fpageurl(winurlexsearchstr,winurlparams,per_page,page_next)});
      (page_curr>=page_max)?faddelem('span',nav,{classList:'button_inactive',title:'already on last page',innerHTML:'&raquo'}):faddelem('a',nav,{classList:'button',title:'last page',id:'button_last',innerHTML:'&raquo',href:fpageurl(winurlexsearchstr,winurlparams,per_page,page_max)});
   }
   else { faddelem('p',document.body,{innerText:'No results returned.'}); };
};

class Result {
  constructor(total_results, per_page, page, recs) {
    this.total_results = total_results;
    this.per_page = per_page;
    this.page = page;
    this.recs = recs;
  }
}

class Record {
  constructor(count, icon, user_login, species_count, obs_count) {
    this.count = count;
    this.icon = icon;
    this.user_login = user_login;
    this.species_count = species_count;
    this.obs_count = obs_count;
  }
}

class Places {
  constructor(places) {
    this.places = places;
  }
}
 
class Place {
  constructor(place_id, place_name) {
    this.place_id = place_id;
    this.place_name = place_name;
  }
}

function storePlaces(data) {
   if (data) {
      let places_array = [];
      for( let i=0; i<data.length; i++ ) {
           const place = new Place(data[i].place_id, data[i].place_name);
           places_array.push(place);
      }
      const places = new Places( JSON.stringify(places_array) );

      // Serialize the object to JSON string so it can be stored in session
      const place_string = JSON.stringify(places);
      sessionStorage.setItem('places', place_string);
   }
   else { faddelem('p',document.body,{innerText:'No places returned.'}); };
}

function parseStoredPlaces(places) {
   // Check if value exists before parsing
   if( places ) {
       // Parse the string back to an object
       const retrievedRec = JSON.parse(places);
       retrievedRec.places = JSON.parse(retrievedRec.places);
       return retrievedRec;
   } else {
       console.log("No object found in session storage for key 'myObject'");
       throw new Error("No object found in session storage.");
   }
} 
  
function storeData(xobj) {
   let results = xobj.results;

   if (results) {
      let record_array = [];
      for( let i=0; i<results.length; i++ ) {
           const record = new Record((i+1), results[i].user.icon, results[i].user.login, results[i].species_count, results[i].observation_count);
           record_array.push(record);
      }
      const result = new Result( xobj.total_results, xobj.per_page, xobj.page, JSON.stringify(record_array) );

      // Serialize the object to JSON string so it can be stored in session
      const result_string = JSON.stringify(result);
      sessionStorage.setItem('anglers', result_string);
   }
   else { faddelem('p',document.body,{innerText:'No results returned.'}); };
}

function parseStoredData(anglers) {
   // Check if value exists before parsing
   if( anglers ) {
       // Parse the string back to an object
       const retrievedRec = JSON.parse(anglers);
       retrievedRec.recs = JSON.parse(retrievedRec.recs);
       return retrievedRec;
   } else {
       console.log("No object found in session storage for key 'myObject'");
       throw new Error("No object found in session storage.");
   }
}

class Taxa {
  constructor(taxa) {
    this.taxa = taxa;
  }
}
 
class Taxon {
  constructor(taxon_id, taxon_name) {
    this.taxon_id = taxon_id;
    this.taxon_name = taxon_name;
  }
}

function storeTaxa(data) {
   if (data) {
      let taxa_array = [];
      for( let i=0; i<data.length; i++ ) {
           const taxon = new Taxon(data[i].taxon_id, data[i].taxon_name);
           taxa_array.push(taxon);
      }
      const taxa = new Taxa( JSON.stringify(taxa_array) );

      // Serialize the object to JSON string so it can be stored in session
      const taxa_string = JSON.stringify(taxa);
      sessionStorage.setItem('taxa', taxa_string);
   }
   else { faddelem('p',document.body,{innerText:'No taxa returned.'}); };
}

function parseStoredTaxa(taxa) {
   // Check if value exists before parsing
   if( taxa ) {
       // Parse the string back to an object
       const retrievedRec = JSON.parse(taxa);
       retrievedRec.taxa = JSON.parse(retrievedRec.taxa);
       return retrievedRec;
   } else {
       console.log("No object found in session storage");
       throw new Error("No object found in session storage.");
   }
} 
 
let apibase = 'https://api.inaturalist.org/v1/observations/observers';
let apiurl = apibase+((winurlparams!='')?('?'+winurlparams):'');
let apirefurl = 'https://api.inaturalist.org/v1/observations/observers';
let apirefname = 'iNaturalist Angling Life Lists';
let apiref = furl(apirefurl,apirefname);

async function asyncGetData() {
   await fetch('life_list_anglers.json')
     .then(response => response.json())
     .then(data => {
      storePlaces(data.places);
      storeTaxa(data.taxa);
   })
     .catch(error => {
      console.error('Error fetching JSON:', error);
   });

   await fetch(apiurl)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+' ('+response.statusText+') returned from '+response.url); };
         return response.json();
      })
       .then((data) => { storeData(data); 
                         fresults( parseStoredData(sessionStorage.getItem('anglers')), parseStoredPlaces(sessionStorage.getItem('places')), parseStoredTaxa(sessionStorage.getItem('taxa')) ); 
                       })
       .catch((err) => {
          console.error(err.message);
          faddelem('p',document.body,{innerText:'There was a problem retrieving data. Error '+err.message+'.'});
      })
}

// need to pull resources from a json file to pass into an api
// so needs to be asynchronous. 
const request = async () => {
   asyncGetData();
}

// cache check will be set to yes for sorting of columns and
// and when "anglers" is cicked on subsequent pages
if( p_cache_check === 'yes' && sessionStorage.getItem('anglers') ) {
    console.log('found session');
    fresults( parseStoredData(sessionStorage.getItem('anglers')), parseStoredPlaces(sessionStorage.getItem('places')), parseStoredTaxa(sessionStorage.getItem('taxa')) );
} else {
    request();  
}
 
</script>

</body>
</html>
